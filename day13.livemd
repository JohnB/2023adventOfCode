<!-- vim: syntax=markdown -->

# Day 13

```elixir
Mix.install([
  {:kino, "~> 0.7.0"}
])

IEx.Helpers.c("/Users/johnb/dev/2022adventOfCode/advent_of_code.ex")
alias AdventOfCode, as: AOC
alias Kino.Input

# Note: when making the next template, something like this works well:
#   `cat day04.livemd | sed 's/03/04/' > day04.livemd`
#
```

## Installation and Data

```elixir
input_p1example = Kino.Input.textarea("Example Data")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_p1puzzleInput = Kino.Input.textarea("Puzzle Input")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
input_source_select =
  Kino.Input.select("Source", [{:example, "example"}, {:puzzle_input, "puzzle input"}])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
p1data = fn ->
  (Kino.Input.read(input_source_select) == :example &&
     Kino.Input.read(input_p1example)) ||
    Kino.Input.read(input_p1puzzleInput)
end
```

## Part 1

```elixir
defmodule Day13 do
  def grid_cells(grid) do
    0..grid.last_cell
  end

  def grid_rows(grid) do
    grid_cells(grid)
    |> Enum.chunk_every(grid.grid_width)
  end

  def grid_x(grid, cell), do: rem(cell, grid.grid_width)
  def grid_y(grid, cell), do: div(cell, grid.grid_width)

  def to_text_grid(grid) do
    grid_rows(grid)
    |> Enum.map(fn row ->
      Enum.map(row, fn x -> grid[x] end)
      |> Enum.join("")
    end)
    |> Enum.join("\n")
  end

  def invert(grid) do
    grid_cells(grid)
    |> Enum.reduce(
      %{
        grid
        | grid_width: grid.grid_height,
          grid_height: grid.grid_width,
          last_cell: grid.last_cell
      },
      fn cell, acc ->
        Map.put(acc, grid_x(grid, cell) * grid.grid_height + grid_y(grid, cell), grid[cell])
      end
    )
  end

  def solve(text) do
    text
    |> AOC.as_doublespaced_paragraphs()
    |> Enum.reduce(0, fn paragraph, acc ->
      rows = AOC.as_single_lines(paragraph)

      cols =
        paragraph
        |> AOC.as_grid()
        |> invert()
        |> to_text_grid()
        |> AOC.as_single_lines()

      midrow =
        rows
        |> Enum.chunk_every(2, 1)
        |> Enum.with_index()
        |> Enum.find(fn {[row1, row2], _index} -> row1 == row2 end)
        |> IO.inspect()

      midcol =
        cols
        |> Enum.chunk_every(2, 1)
        |> Enum.with_index()
        |> Enum.find(fn {[row1, row2], _index} -> row1 == row2 end)
        |> IO.inspect()

      IO.inspect([midrow, midcol], label: "midrow & col")
      acc + ((midrow && (1 + elem(midrow, 1)) * 10) || 1 + elem(midcol, 1))
    end)
  end

  def solve2(text) do
    text
  end
end

p1data.()
|> Day13.solve()
|> IO.inspect(label: "\n*** Part 1 solution (example: 405)")

#

# p1data.()
# |> Day13.solve2()
# |> IO.inspect(label: "\n*** Part 2 solution (example: )")

#
```
